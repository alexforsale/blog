#+title: Stumpwm
#+date: <2022-03-19 Sat>
#+author: Kristian Alexander P
#+email: alexforsale@yahoo.com
#+language: en
#+startup: overview hideblocks
* Configuration file
  :PROPERTIES:
  :header-args: :tangle ~/.config/stumpwm/config :mkdirp t
  :END:
** Header
   Needed so /Emacs/ will use /lisp major-mode/ for this file since it's not using /.lisp/ extension.
   #+begin_src lisp :shebang ;; -*-lisp-*-
     ;;
     ;; This file is autogenerated, do not edit.
   #+end_src
** Load =quicklisp=
   Load my installation of /quicklisp/. The special operator =let= creates new variable =quicklisp-init= and executes a series of /form/ (here just runs the /macro/ =when=) that uses these /bindings/.
   #+begin_src lisp
     (let ((quicklisp-init
             (merge-pathnames ".local/share/quicklisp/setup.lisp" (user-homedir-pathname))))
       (when (probe-file quicklisp-init)
         (load quicklisp-init)))
   #+end_src
   - =merge-pathnames= is similar to /python/'s =os.path.join()=.
   - The variable =user-homedir-pathname= returns a [[http://www.lispworks.com/documentation/HyperSpec/Body/26_glo_p.htm#pathname][pathname]] without any name, type or version component (those component are all /nil/) for the user's home directory on /host (not used here)/.
   - =probe-file= tests whether a file exists[fn:1]
** load stumpwm from quicklisp
   #+begin_src lisp
     (ql:quickload :stumpwm)
   #+end_src
** Swank
   Requires =swank= (from the package =slime=) in order to run the function =swank-loader=. Again I use the special operator =let= to dynamically creates the /stumpwm/ command =swank=, this command can be run inside /stumpwm/ for toggling /swank/.
   #+begin_src lisp
      (require :swank)
      (swank-loader:init)
      (let ((server-running nil))
        (defcommand swank () ()
          "Toggle the swank server on/off"
          (if server-running
              (progn
                (swank:stop-server 4004)
                (echo-string
                 (current-screen)
                 "Stopping swank.")
                (setf server-running nil))
              (progn
                (swank:create-server :port 4004
                                     :style swank:*communication-style*
                                     :dont-close t)
                (echo-string
                 (current-screen)
                 "Starting swank. M-x slime-connect RET RET, then (in-package stumpwm).")
                (setf server-running t)))))
   #+end_src
** Stumpwm configuration
   The macro =in-package= causes the package named to be the current packages; that is, the value of =*package*=. In short it'll let us to call =run-shell-command= instead of =stuwmpm:run-shell-command=, this also works for variables.
   #+begin_src lisp
      (in-package :stumpwm)

      (setf *mouse-focus-policy* :sloppy)
      (setf *run-or-raise-all-groups* t)
      (setf *run-or-raise-all-screens* t)
   #+end_src
   - =*mouse-focus-policy*= :: This variable decide how the mouse affects input focus. Possible values are ~:ignore~, ~:sloppy~ and ~:click~.
   - =*run-or-raise-all-groups*= :: Defines how the =run-or-raise= function searches, in this case all groups.
   - =*run-or-raise-all-screens*= :: Same as above, but to /screens/.
** Load contrib modules
   Check if =~/.config/stumpwm/modules= exists, and add it to the /stumpwm/ module-dir using the function =set-module-dir=.
   #+begin_src lisp
     (let ((module-dir (truename "~/.config/stumpwm/modules")))
       (when (directory-pathname-p module-dir)
         (set-module-dir module-dir)))
   #+end_src
   The /modules/ directory itself is a git repository of the [[https://github.com/stumpwm/stumpwm-contrib.git][stumpwm-contrib]]. Currently the only dependency from the /contrib/ modules is [[https://github.com/stumpwm/stumpwm-contrib/blob/master/util/stumpish/stumpish][stumpish]], an interactive shell for /stumpwm/.
   #+begin_src sh :tangle no
     if ! test -d ~/.config/stumpwm/modules; then
         git clone https://github.com/stumpwm/stumpwm-contrib.git ~/.config/stumpwm/modules
     fi
   #+end_src
   Also create a symlink for /stumpish/ to =~/.local/bin=
   #+begin_src sh :tangle no
     [ ! -d ~/.local/bin ] && mkdir -p ~/.local/bin
     pushd ~/.local/bin
     [ ! -L stumpish ] && ln -sv ../../.config/stumpwm/modules/util/stumpish/stumpish stumpish
     popd
   #+end_src
** Colors

** Autostarts
   The variable =*initializing*= is only set to =T= when /stumpwm/ is starting up. Which means once per session. Useful for starting up applications that only needed at startup.
   #+begin_src lisp
     (when *initializing*
       (progn
         (run-shell-command "xsetroot -cursor_name left_ptr")
         (run-shell-command "nm-applet")
         (run-shell-command "dunst")
         (run-shell-command "picom")
         (run-shell-command "unclutter")
         (run-shell-command "blueman-applet")
         (run-shell-command "xsettingsd")
         (run-shell-command "udiskie -t")
         (which-key-mode)))
   #+end_src
** mode-line
   The mode line is a bar that runs across either the top or bottom of a head and is used to display information.  By default the mode line displays the list of windows, similar to the output =C-t w= produces.
   #+begin_src lisp
      (setf *window-format* "%m%n%s%c")
      (setf *screen-mode-line-format* (list "[^B%n^b] %W^>%d"))
      (setf *time-modeline-string* "%a %b %e %k:%M")
      (setf *mode-line-timeout* 2)
      (enable-mode-line (current-screen) (current-head) t)
   #+end_src
   - =*window-format*= :: This variable decides how the window list is formatted.  It is a string with the following formatting options:
     - =%m= :: Draw a =#= if the window is marked.
     - =%n= :: Substitutes the window's number translated via =*window-number-map*=, if there are more windows than =*window-number-map*= then will use the window-number.
     - =%s= :: Substitute the window's status.  =*= means current window, =+= means last window, and - means any other window.
     - =%c= :: Substitute the window's class.
   - =*screen-mode-line-format*= :: This variable describes what will be displayed on the modeline for each screen.  Turn it on with the function =TOGGLE-MODE-LINE= or the =mode-line= command. It is a list where each element may be a string, a symbol, or a list. For a symbol its value is used. For a list of the form ~(:eval FORM)~ =FORM= is evaluated and the result is used as a mode line element. If it is a string the string is printed with the following formatting options:
     - =%n= :: The current group's name.
     - =%W= :: List all windows on the current head of the current group using =*WINDOW-FORMAT*=
     - =%d= :: Using =*TIME-MODELINE-STRING*=, print the time.
     This variable also uses with the color commands (see ~info (stumpwm)Colors~):
     - =^B= :: Turn on bright colors.
     - =^b= :: Turn off bright colors.
   - =*time-modeline-string*= :: The default time value to pass to the modeline. This is using the /GNU coreutils/ format, see ~info "(coreutils)Date conversion specifiers"~ for details.
   - =*mode-line-timeouts*= :: The modeline updates after each command, when a new window appears or an existing one disappears, and on a timer.  This variable controls how many seconds elapse between each update.  If this variable is changed while the modeline is visible, you must toggle the modeline to update timer.
   The last line =(enable-mode-line (current-screen) (current-head) t)= runs the mode-line.
** The Keybindings
   There are several variables that defines when a /keybinding/ is used:
   - =*root-map*= :: Known as the "/prefix-map/".
   - =*top-map*= :: This is where you'll find the bindings for the "/prefix-map/".
   - =*group-map*= :: The keymap that group related key bindings sit on.
   - =*group-top-map*= :: An alist of the top level maps for each group type.
   - =*exchange-window-map*= :: The keymap that =exchange-window= key bindings sit on.
*** Sets the prefix
    Here I'm using =s-d= (/Super Key/ and "d").
    #+begin_src lisp
       ;; change the prefix key to something else
       (set-prefix-key (kbd "s-d"))
    #+end_src
    The =kbd= itself is a function specific to /stumpwm/.
*** Undefine default keybindings
    These are keybindings that I don't use very often, or at all.
    #+begin_src lisp
      ;; default to `exec' `xterm'
      (dolist (xterm '((kbd "c") (kbd "C-c")))
        undefine-key *root-map* xterm)

      ;; default to `quit-confirm'
      (undefine-key *root-map* (kbd "q"))

      ;; *exchange-window-map*
      ;; TODO: set this elsewhere
      (undefine-key *root-map* (kbd "x"))
    #+end_src
*** Remap =colon=, and =quit-confirm=
    Make it like /Emacs/'s ~M-x~
    #+begin_src lisp
      (define-key *top-map* (kbd "s-M-x") "colon")
    #+end_src
    I usually bind ~C-s-q~ for quitting /WM/'s.
    #+begin_src lisp
      (define-key *top-map* (kbd "C-s-q") "quit-confirm")
    #+end_src
*** Terminal Emulator
    Although /XTerm/ is my default terminal-emulator, I sometimes try tinkering with other programs, so I set the =$TERMINAL= environment variable to set my current terminal-emulator.
    #+begin_src lisp
      (let ((terminal (or (getenv "TERMINAL")
                          "xterm")))
        (setf *terminal-emulator* terminal))

      (defcommand terminal () ()
        (run-or-raise *terminal-emulator* `(:class ,*terminal-emulator*)))
    #+end_src
    And my default keybinding is ~s-RET~.
    #+begin_src lisp
      (define-key *top-map* (kbd "s-RET") "terminal")
    #+end_src
*** Media Keys
**** Volume
     Using /PulseAudio/.
     #+begin_src lisp
       (define-key *top-map* (kbd "XF86AudioLowerVolume") "exec pactl -- set-sink-volume @DEFAULT_SINK@ -5%")
       (define-key *top-map* (kbd "XF86AudioRaiseVolume") "exec pactl -- set-sink-volume @DEFAULT_SINK@ +5%")
       (define-key *top-map* (kbd "XF86AudioMute") "exec pactl -- set-sink-mute @DEFAULT_SINK@ toggle")
     #+end_src
*** Group selections
    #+begin_src lisp
       ;; group movement
       (define-key *top-map* (kbd "s-1") "gselect 1")
       (define-key *top-map* (kbd "s-2") "gselect 2")
       (define-key *top-map* (kbd "s-3") "gselect 3")
       (define-key *top-map* (kbd "s-4") "gselect 4")
       (define-key *top-map* (kbd "s-5") "gselect 5")
       (define-key *top-map* (kbd "s-6") "gselect 6")
       (define-key *top-map* (kbd "s-7") "gselect 7")
       (define-key *top-map* (kbd "s-8") "gselect 8")
       (define-key *top-map* (kbd "s-9") "gselect 9")
       (define-key *top-map* (kbd "s-0") "gselect 10")

       (define-key *top-map* (kbd "s-TAB") "gother")
   #+end_src
*** Custom functions, commands and macros
**** colon1
     This is a custom command from the default configuration that prompt the user for an interactive command. The first arg is an optional initial contents.
     #+begin_src lisp :tangle no
       (defcommand colon1 (&optional (initial "")) (:rest)
         (let ((cmd (read-one-line (current-screen) ": " :initial-input initial)))
           (when cmd
             (eval-command cmd t))))
     #+end_src
     Note that in /stumpwm/ there's also the /command/ =colon= by default.
**** make-web-jump
     Also from the default configuration, currently sets for /DuckDuckGo/ and /IMDB/.
     #+begin_src lisp :tangle no
       (defmacro make-web-jump (name prefix)
         `(defcommand ,(intern name) (search) ((:rest ,(concatenate 'string name " search: ")))
            (nsubstitute #\+ #\Space search)
            (run-shell-command (concatenate 'string ,prefix search))))

       (make-web-jump "duckduckgo" "firefox https://duckduckgo.com/?q=")
       (make-web-jump "imdb" "firefox http://www.imdb.com/find?q=")
     #+end_src
*** Keybinding Tree
    This is what in /Emacs/ called "keychord" (I think). So, ~s-h v~ is for the function =describe-variable= and so on.
    #+begin_src lisp
      (defvar *my-describe-bindings*
        (let ((m (make-sparse-keymap)))
          (define-key m (kbd "v") "describe-variable")
          (define-key m (kbd "f") "describe-function")
          (define-key m (kbd "c") "describe-command")
          (define-key m (kbd "k") "describe-key")
          m))
    #+end_src
    Also note that since I'm already use ~s-d h~ this means I'm not using the usual /window-manager/ /vim/ keybindings (=h=, =j=, =k=, =l=). Also since "=h=" is actually already bound in =*top-map*= I need to unbind it in order to set it for =*my-describe-bindings*=.
   #+begin_src lisp
       ;; help
       (undefine-key *root-map* (kbd "h"))
       (define-key *top-map* (kbd "s-h") '*my-describe-bindings*)
   #+end_src
*** Swank
    This called the =swank= command defined [[*Swank][earlier]]. Use this command to hack the /stumpwm/ configuration in real time.
   #+begin_src lisp
     (define-key *root-map* (kbd "C-s") "swank")
   #+end_src
   Note that in order to run /stumpwm/ command without the ~stumpwm:~ prefix, you need to first run ~(in-package :stumpwm)~.
*** imdb and duckduckgo
    This is from the default configuration, I don't use this often.
    #+begin_src lisp :tangle no
       (define-key *root-map* (kbd "M-s") "duckduckgo")
       (define-key *root-map* (kbd "i") "imdb")
    #+end_src
** Message window font
   #+begin_src lisp
      ;; Message window font
      (set-font "-xos4-terminus-medium-r-normal--14-140-72-72-c-80-iso8859-15")
   #+end_src
** Window rules
   First we need to clear the previous rules in order to create a new one.
   #+begin_src lisp
      (clear-window-placement-rules)
   #+end_src
** Frame preferences
   #+begin_src lisp
     ;; Last rule to match takes precedence!
     ;; TIP: if the argument to :title or :role begins with an ellipsis, a substring
     ;; match is performed.
     ;; TIP: if the :create flag is set then a missing group will be created and
     ;; restored from *data-dir*/create file.
     ;; TIP: if the :restore flag is set then group dump is restored even for an
     ;; existing group using *data-dir*/restore file.
     (define-frame-preference "Default"
       ;; frame raise lock (lock AND raise == jumpto)
       (0 t nil :class "Konqueror" :role "...konqueror-mainwindow")
       (1 t nil :class "XTerm")
       (0 t t :class *terminal-emulator*))

     (define-frame-preference "Ardour"
       (0 t   t   :instance "ardour_editor" :type :normal)
       (0 t   t   :title "Ardour - Session Control")
       (0 nil nil :class "XTerm")
       (1 t   nil :type :normal)
       (1 t   t   :instance "ardour_mixer")
       (2 t   t   :instance "jvmetro")
       (1 t   t   :instance "qjackctl")
       (3 t   t   :instance "qjackctl" :role "qjackctlMainForm"))

     (define-frame-preference "Shareland"
       (0 t   nil :class "XTerm")
       (1 nil t   :class "aMule"))

     (define-frame-preference "Emacs"
       (1 t t :restore "emacs-editing-dump" :title "...xdvi")
       (0 t t :create "emacs-dump" :class "Emacs"))
   #+end_src


* Footnotes

[fn:1] http://www.lispworks.com/documentation/lw51/CLHS/Body/f_probe_.htm

#+include: ../utterances.inc


#+include: ../utterances.inc
